{"version":3,"file":"static/js/999.305b45ad.chunk.js","mappings":"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","sources":["../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/utils/focus.ts","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/components/ld-context-menu/ld-context-menu.shadow.css?tag=ld-context-menu&encapsulation=shadow","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/components/ld-context-menu/ld-context-menu.tsx","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/utils/type-checking.ts"],"sourcesContent":["export const focusableSelector = [\n  'a[href]',\n  'area[href]',\n  'input:not([type=\"hidden\"]):not([type=\"radio\"]):not(:disabled)',\n  'input[type=\"radio\"]:not(:disabled)',\n  'select:not(:disabled)',\n  'textarea:not(:disabled)',\n  'button:not(:disabled)',\n  'iframe',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]',\n  '[tabindex]',\n]\n  .map((selector) => selector + ':not([tabindex^=\"-\"])')\n  .join(',')\n\nexport const getFirstFocusable = (el: HTMLElement): HTMLElement | undefined => {\n  // Directly focusable element.\n  if (el.matches(focusableSelector)) {\n    return el\n  }\n\n  // Slot.\n  if (el.tagName === 'SLOT') {\n    const hostEl = el.getRootNode()['host']\n    const slotName = el.getAttribute('name')\n    const slottedEl = slotName\n      ? hostEl.querySelector(`[slot=\"${el.getAttribute('name')}\"]`)\n      : Array.from(hostEl.children).find(\n          (child) => !(child as HTMLElement).hasAttribute('slot')\n        )\n    if (slottedEl) {\n      return getFirstFocusable(slottedEl)\n    }\n    return null\n  }\n\n  // Web Component.\n  if (el.shadowRoot) {\n    const shadowRootChildren = Array.from(el.shadowRoot.children)\n    for (const child of shadowRootChildren) {\n      const focusable = getFirstFocusable(child as HTMLElement)\n      if (focusable) return focusable\n    }\n  }\n\n  // Element with children.\n  const children = Array.from(el.children)\n  for (const child of children) {\n    const focusable = getFirstFocusable(child as HTMLElement)\n    if (focusable) return focusable\n  }\n\n  return null\n}\n\nexport const isInnerFocusable = <T extends object>(\n  element?: T\n): element is T & InnerFocusable => element && 'focusInner' in element\n\nlet autofocusHandlerTimeout\nexport const registerAutofocus = (autofocus: boolean) => {\n  if (!autofocus || autofocusHandlerTimeout) return\n  autofocusHandlerTimeout = setTimeout(() => {\n    const firstWithAutofocus = Array.from(\n      document.querySelectorAll<HTMLInputElement>('[autofocus]')\n    ).find((el) => !el.disabled)\n    if (isInnerFocusable(firstWithAutofocus)) {\n      firstWithAutofocus.focusInner()\n    }\n  }, 200)\n}\n\nexport const focusInnerOrFocus = (element: HTMLElement) => {\n  if (isInnerFocusable(element)) {\n    element.focusInner()\n  } else {\n    element.focus()\n  }\n}\n",":host {\n  display: inline-flex;\n}\n","import {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Method,\n  Prop,\n  State,\n  Watch,\n} from '@stencil/core'\nimport { isHtmlElement } from '../../utils/type-checking'\nimport { isInnerFocusable } from '../../utils/focus'\n\n/**\n * @virtualProp ref - reference to component\n * @virtualProp {string | number} key - for tracking the node's identity when working with lists\n * @part menu - `ld-menu` element wrapping the default slot\n * @part tooltip - `ld-tooltip` element\n */\n@Component({\n  tag: 'ld-context-menu',\n  styleUrl: 'ld-context-menu.shadow.css',\n  shadow: true,\n})\nexport class LdContextMenu {\n  @Element() el: HTMLLdContextMenuElement\n  private menuRef: HTMLLdMenuElement\n  private tooltipRef: HTMLLdTooltipElement\n  private triggerSlotRef: HTMLSlotElement\n\n  /** Position of the context menu relative to the trigger element. */\n  @Prop() position?: HTMLLdTooltipElement['position'] = 'bottom left'\n\n  /** Use right-click. */\n  @Prop() rightClick? = false\n\n  /** Size of the context menu. */\n  @Prop() size?: 'sm' | 'lg'\n\n  /** Tether options object to be merged with the default options (optionally stringified). */\n  @Prop() tetherOptions?: Partial<Tether.ITetherOptions> | string\n\n  @State() initialized = false\n\n  private resetFocus = async () => {\n    const [trigger] = this.triggerSlotRef.assignedElements()\n\n    if (isInnerFocusable(trigger)) {\n      await trigger.focusInner()\n      return\n    }\n\n    if (isHtmlElement(trigger)) {\n      trigger.focus()\n    }\n  }\n\n  private focusFirstMenuitem = async (menuInTooltip: HTMLLdMenuElement) => {\n    const firstMenuItem = await menuInTooltip.getFirstMenuItem()\n\n    if (!firstMenuItem) {\n      return\n    }\n\n    await firstMenuItem.focusInner()\n  }\n\n  private handleKeyDown = async (event: KeyboardEvent) => {\n    switch (event.key) {\n      case 'Escape':\n        event.preventDefault()\n        await this.tooltipRef.hideTooltip()\n        break\n      case 'Tab':\n        event.preventDefault()\n    }\n  }\n\n  private handleMenuOpen = async () => {\n    const tooltip = await this.tooltipRef.getTooltip()\n    const menuInTooltip = tooltip.querySelector('ld-menu')\n\n    if (!this.initialized) {\n      menuInTooltip.addEventListener('keydown', this.handleKeyDown)\n      this.initialized = true\n    }\n\n    this.focusFirstMenuitem(menuInTooltip)\n    this.ldcontextmenuopen.emit()\n  }\n\n  private handleMenuClose = () => {\n    this.resetFocus()\n    this.ldcontextmenuclose.emit()\n  }\n\n  /** Emitted when the context menu is opened. */\n  @Event() ldcontextmenuopen: EventEmitter\n\n  /** Emitted when the context menu is closed. */\n  @Event() ldcontextmenuclose: EventEmitter\n\n  /** Show context menu */\n  @Method()\n  async showContextMenu() {\n    await this.tooltipRef.showTooltip()\n  }\n\n  /** Hide context menu */\n  @Method()\n  async hideContextMenu() {\n    await this.tooltipRef.hideTooltip()\n  }\n\n  @Watch('size')\n  private updateSize() {\n    if (this.size) {\n      this.menuRef.setAttribute('size', this.size)\n    } else {\n      this.menuRef.removeAttribute('size')\n    }\n  }\n\n  componentDidLoad() {\n    const style = this.el.getAttribute('style')\n\n    this.updateSize()\n\n    if (style) {\n      this.menuRef.setAttribute('style', style)\n      this.el.removeAttribute('style')\n    }\n\n    this.triggerSlotRef\n      .assignedElements()\n      .forEach((element) => (element.ariaHasPopup = 'menu'))\n  }\n\n  render() {\n    return (\n      <ld-tooltip\n        onLdtooltipclose={this.handleMenuClose}\n        onLdtooltipopen={this.handleMenuOpen}\n        ref={(element: HTMLLdTooltipElement) => (this.tooltipRef = element)}\n        rightClick={this.rightClick}\n        part=\"tooltip\"\n        position={this.position}\n        preventScreenreader\n        tag=\"span\"\n        tetherOptions={this.tetherOptions}\n        triggerType=\"click\"\n        unstyled\n      >\n        <slot\n          name=\"trigger\"\n          ref={(element: HTMLSlotElement) => (this.triggerSlotRef = element)}\n          slot=\"trigger\"\n        />\n        <ld-menu\n          part=\"menu\"\n          ref={(el: HTMLLdMenuElement) => (this.menuRef = el)}\n        >\n          <slot />\n        </ld-menu>\n      </ld-tooltip>\n    )\n  }\n}\n","export const isElement = (node: Node): node is Element =>\n  'querySelectorAll' in node\n\nexport const isHtmlElement = (element?: Element): element is HTMLElement =>\n  'focus' in element\n\nexport const isMenuItem = (\n  element: Element\n): element is HTMLLdMenuitemElement => element.tagName === 'LD-MENUITEM'\n\nexport const isSlot = (element: Element): element is HTMLSlotElement =>\n  element.tagName === 'SLOT'\n"],"names":["focusableSelector","map","selector","join","getFirstFocusable","el","matches","tagName","hostEl","getRootNode","slottedEl","getAttribute","querySelector","Array","from","children","find","child","hasAttribute","shadowRoot","shadowRootChildren","focusable","isInnerFocusable","element","autofocusHandlerTimeout","registerAutofocus","autofocus","setTimeout","firstWithAutofocus","document","querySelectorAll","disabled","focusInner","focusInnerOrFocus","focus","LdContextMenu","resetFocus","async","trigger","this","triggerSlotRef","assignedElements","isHtmlElement","focusFirstMenuitem","firstMenuItem","menuInTooltip","getFirstMenuItem","handleKeyDown","event","key","preventDefault","tooltipRef","hideTooltip","handleMenuOpen","getTooltip","initialized","addEventListener","ldcontextmenuopen","emit","handleMenuClose","ldcontextmenuclose","showContextMenu","showTooltip","hideContextMenu","updateSize","size","menuRef","setAttribute","removeAttribute","componentDidLoad","style","forEach","ariaHasPopup","render","h","onLdtooltipclose","onLdtooltipopen","ref","rightClick","part","position","preventScreenreader","tag","tetherOptions","triggerType","unstyled","name","slot","isElement","node","isMenuItem","isSlot"],"sourceRoot":""}