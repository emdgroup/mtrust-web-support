{"version":3,"file":"static/js/4041.e7c4c47f.chunk.js","mappings":"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","sources":["../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/utils/focus.ts","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/components/ld-context-menu/ld-menu/ld-menu.css?tag=ld-menu&encapsulation=shadow","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/components/ld-context-menu/ld-menu/ld-menu.tsx","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/utils/type-checking.ts","../node_modules/.pnpm/@emdgroup-liquid+liquid@5.14.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@emdgroup-liquid/liquid/dist/esm/src/liquid/utils/typeahead.ts"],"sourcesContent":["export const focusableSelector = [\n  'a[href]',\n  'area[href]',\n  'input:not([type=\"hidden\"]):not([type=\"radio\"]):not(:disabled)',\n  'input[type=\"radio\"]:not(:disabled)',\n  'select:not(:disabled)',\n  'textarea:not(:disabled)',\n  'button:not(:disabled)',\n  'iframe',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]',\n  '[tabindex]',\n]\n  .map((selector) => selector + ':not([tabindex^=\"-\"])')\n  .join(',')\n\nexport const getFirstFocusable = (el: HTMLElement): HTMLElement | undefined => {\n  // Directly focusable element.\n  if (el.matches(focusableSelector)) {\n    return el\n  }\n\n  // Slot.\n  if (el.tagName === 'SLOT') {\n    const hostEl = el.getRootNode()['host']\n    const slotName = el.getAttribute('name')\n    const slottedEl = slotName\n      ? hostEl.querySelector(`[slot=\"${el.getAttribute('name')}\"]`)\n      : Array.from(hostEl.children).find(\n          (child) => !(child as HTMLElement).hasAttribute('slot')\n        )\n    if (slottedEl) {\n      return getFirstFocusable(slottedEl)\n    }\n    return null\n  }\n\n  // Web Component.\n  if (el.shadowRoot) {\n    const shadowRootChildren = Array.from(el.shadowRoot.children)\n    for (const child of shadowRootChildren) {\n      const focusable = getFirstFocusable(child as HTMLElement)\n      if (focusable) return focusable\n    }\n  }\n\n  // Element with children.\n  const children = Array.from(el.children)\n  for (const child of children) {\n    const focusable = getFirstFocusable(child as HTMLElement)\n    if (focusable) return focusable\n  }\n\n  return null\n}\n\nexport const isInnerFocusable = <T extends object>(\n  element?: T\n): element is T & InnerFocusable => element && 'focusInner' in element\n\nlet autofocusHandlerTimeout\nexport const registerAutofocus = (autofocus: boolean) => {\n  if (!autofocus || autofocusHandlerTimeout) return\n  autofocusHandlerTimeout = setTimeout(() => {\n    const firstWithAutofocus = Array.from(\n      document.querySelectorAll<HTMLInputElement>('[autofocus]')\n    ).find((el) => !el.disabled)\n    if (isInnerFocusable(firstWithAutofocus)) {\n      firstWithAutofocus.focusInner()\n    }\n  }, 200)\n}\n\nexport const focusInnerOrFocus = (element: HTMLElement) => {\n  if (isInnerFocusable(element)) {\n    element.focusInner()\n  } else {\n    element.focus()\n  }\n}\n",":host {\n  display: inline-flex;\n}\n\n.ld-menu {\n  background: var(--ld-col-wht);\n  border-radius: var(--ld-br-l);\n  box-shadow: var(--ld-shadow-stacked);\n  box-sizing: border-box;\n  list-style: none;\n  margin: 0;\n  padding: var(--ld-sp-12);\n}\n","import {\n  Component,\n  Element,\n  h,\n  Host,\n  Method,\n  Prop,\n  State,\n  Watch,\n} from '@stencil/core'\nimport { TypeAheadHandler } from '../../../utils/typeahead'\nimport { isElement, isMenuItem, isSlot } from '../../../utils/type-checking'\n\nconst getMenuItemOrNestedMenuItems = (node: Node) => {\n  if (!isElement(node)) {\n    return []\n  }\n\n  if (isMenuItem(node)) {\n    return [node]\n  }\n\n  const items: HTMLLdMenuitemElement[] = []\n\n  if (isSlot(node)) {\n    node\n      .assignedNodes()\n      .forEach((node) => items.push(...getMenuItemOrNestedMenuItems(node)))\n    return items\n  }\n\n  node.childNodes.forEach((node) =>\n    items.push(...getMenuItemOrNestedMenuItems(node))\n  )\n\n  return items\n}\n\n/**\n * @virtualProp ref - reference to component\n * @virtualProp {string | number} key - for tracking the node's identity when working with lists\n * @part list - `ul` element wrapping the default slot\n */\n@Component({\n  tag: 'ld-menu',\n  styleUrl: 'ld-menu.css',\n  shadow: true,\n})\nexport class LdMenu {\n  @Element() el: HTMLLdMenuElement\n\n  /** Size of the context menu. */\n  @Prop() size?: 'sm' | 'lg'\n\n  @State() initialized = false\n  @State() typeAheadHandler: TypeAheadHandler<HTMLLdMenuitemElement>\n\n  private initMenuItems = (element: Node, initial = false) => {\n    if (!isElement(element)) {\n      return\n    }\n\n    if (isMenuItem(element)) {\n      element.size = this.size\n\n      if (!initial) {\n        return\n      }\n\n      element.ldTabindex = this.initialized ? -1 : 0\n\n      if (!this.initialized) {\n        this.initialized = true\n      }\n\n      return\n    }\n\n    if (isSlot(element)) {\n      element.assignedNodes().forEach((node) => this.initMenuItems(node))\n      return\n    }\n\n    element.childNodes.forEach((node) => this.initMenuItems(node))\n  }\n\n  /** Get the first menu item inside this menu. */\n  @Method()\n  async getFirstMenuItem(): Promise<HTMLLdMenuitemElement> {\n    return this.getAllMenuItems()[0]\n  }\n\n  private getAllMenuItems = () => {\n    const items: HTMLLdMenuitemElement[] = []\n\n    this.el\n      .querySelectorAll('slot, ld-menuitem')\n      .forEach((node) => items.push(...getMenuItemOrNestedMenuItems(node)))\n\n    return items\n  }\n\n  private focusFirst = (target: HTMLLdMenuitemElement) => {\n    const allMenuItems = this.getAllMenuItems()\n    const [first] = allMenuItems\n\n    target.ldTabindex = -1\n    first.ldTabindex = 0\n    first.focusInner()\n  }\n\n  private focusLast = (target: HTMLLdMenuitemElement) => {\n    const allMenuItems = this.getAllMenuItems()\n    const last = allMenuItems[allMenuItems.length - 1]\n\n    target.ldTabindex = -1\n    last.ldTabindex = 0\n    last.focusInner()\n  }\n\n  private focusNext = (target: HTMLLdMenuitemElement) => {\n    const allMenuItems = this.getAllMenuItems()\n    const index = allMenuItems.indexOf(target)\n    const next =\n      allMenuItems.length > index + 1\n        ? allMenuItems[index + 1]\n        : allMenuItems[0]\n\n    target.ldTabindex = -1\n    next.ldTabindex = 0\n    next.focusInner()\n  }\n\n  private focusPrev = (target: HTMLLdMenuitemElement) => {\n    const allMenuItems = this.getAllMenuItems()\n    const index = allMenuItems.indexOf(target)\n    const prev =\n      index === 0\n        ? allMenuItems[allMenuItems.length - 1]\n        : allMenuItems[index - 1]\n\n    target.ldTabindex = -1\n    prev.ldTabindex = 0\n    prev.focusInner()\n  }\n\n  private handleKeyDown = (event: KeyboardEvent) => {\n    const target = event.target as HTMLLdMenuitemElement\n    let focusedElement: HTMLLdMenuitemElement\n\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault()\n        if (event.metaKey) {\n          this.focusFirst(target)\n        } else {\n          this.focusPrev(target)\n        }\n        break\n      case 'ArrowDown':\n        event.preventDefault()\n        if (event.metaKey) {\n          this.focusLast(target)\n        } else {\n          this.focusNext(target)\n        }\n        break\n      case 'Home':\n        event.preventDefault()\n        this.focusFirst(target)\n        break\n      case 'End':\n        event.preventDefault()\n        this.focusLast(target)\n        break\n      default:\n        focusedElement = this.typeAheadHandler.typeAhead(event.key, target)\n\n        if (focusedElement) {\n          target.ldTabindex = -1\n          focusedElement.ldTabindex = 0\n        }\n    }\n  }\n\n  @Watch('size')\n  handleSizeChange() {\n    this.updateMenuItems()\n  }\n\n  private updateMenuItems = (initial = false) => {\n    this.el\n      .querySelectorAll('slot, ld-menuitem')\n      .forEach((element) => this.initMenuItems(element, initial))\n  }\n\n  componentWillLoad() {\n    this.updateMenuItems(true)\n    this.typeAheadHandler = new TypeAheadHandler(this.getAllMenuItems())\n  }\n\n  disconnectedCallback() {\n    this.typeAheadHandler?.clearTimeout()\n  }\n\n  render() {\n    return (\n      <Host onKeyDown={this.handleKeyDown}>\n        <ul class=\"ld-menu\" part=\"list\" role=\"menu\">\n          <slot />\n        </ul>\n      </Host>\n    )\n  }\n}\n","export const isElement = (node: Node): node is Element =>\n  'querySelectorAll' in node\n\nexport const isHtmlElement = (element?: Element): element is HTMLElement =>\n  'focus' in element\n\nexport const isMenuItem = (\n  element: Element\n): element is HTMLLdMenuitemElement => element.tagName === 'LD-MENUITEM'\n\nexport const isSlot = (element: Element): element is HTMLSlotElement =>\n  element.tagName === 'SLOT'\n","import { focusInnerOrFocus } from './focus'\n\nconst isPrintableCharacter = (key: string) =>\n  key.length === 1 && key.match(/\\S/)\n\nexport class TypeAheadHandler<T extends HTMLElement> {\n  private currentIndex: number\n  private typeAheadQuery = ''\n  private typeAheadTimeout: number\n  private _options: T[]\n\n  constructor(optionNodes: NodeListOf<T> | T[]) {\n    this.options = optionNodes\n  }\n\n  set options(optionNodes: NodeListOf<T> | T[]) {\n    this._options = Array.isArray(optionNodes)\n      ? optionNodes\n      : Array.from(optionNodes)\n  }\n\n  private getElementByQuery = () => {\n    if (!this.typeAheadQuery) return\n\n    const query = this.typeAheadQuery.toLowerCase()\n    const values = this._options.map((option) =>\n      option.textContent.trim().toLowerCase()\n    )\n    let index = values.findIndex(\n      (value, index) => index > this.currentIndex && value.indexOf(query) === 0\n    )\n\n    // only search again from index 0, if you previously started from an index > 0\n    if (index === -1 && this.currentIndex > -1) {\n      index = values.findIndex((value) => value.indexOf(query) === 0)\n    }\n\n    if (index > -1) {\n      return this._options[index]\n    }\n\n    // find the first value that is alphabetically following the query\n    const matchingLabel = [...values].sort().find((value) => query < value)\n\n    if (matchingLabel) {\n      return this._options[values.indexOf(matchingLabel)]\n    }\n  }\n\n  clearTimeout() {\n    window.clearTimeout(this.typeAheadTimeout)\n  }\n\n  /**\n   * Type a character: focus moves to the next item with a name that starts\n   * with the typed character. Type multiple characters in rapid succession:\n   * focus moves to the next item with a name that starts with the string of\n   * characters typed.\n   * @param key typed key\n   * @returns The focused element, if any\n   */\n  typeAhead = (key: string, currentElement?: T) => {\n    if (!isPrintableCharacter(key)) {\n      return\n    }\n\n    // set the current index only once while adding to a typeahead query\n    if (!this.typeAheadQuery) {\n      this.currentIndex = currentElement\n        ? this._options.indexOf(currentElement)\n        : -1\n    }\n\n    this.typeAheadQuery = this.typeAheadQuery + key\n\n    const focusableElement = this.getElementByQuery()\n\n    if (focusableElement) {\n      focusInnerOrFocus(focusableElement)\n    }\n\n    this.clearTimeout()\n    this.typeAheadTimeout = window.setTimeout(() => {\n      this.typeAheadQuery = ''\n    }, 500)\n\n    return focusableElement\n  }\n}\n"],"names":["focusableSelector","map","selector","join","getFirstFocusable","el","matches","tagName","hostEl","getRootNode","slottedEl","getAttribute","querySelector","Array","from","children","find","child","hasAttribute","shadowRoot","shadowRootChildren","focusable","isInnerFocusable","element","autofocusHandlerTimeout","registerAutofocus","autofocus","setTimeout","firstWithAutofocus","document","querySelectorAll","disabled","focusInner","focusInnerOrFocus","focus","getMenuItemOrNestedMenuItems","node","isElement","isMenuItem","items","isSlot","assignedNodes","forEach","push","childNodes","LdMenu","initMenuItems","initial","arguments","length","undefined","size","_this","ldTabindex","initialized","getAllMenuItems","this","focusFirst","target","allMenuItems","first","focusLast","last","focusNext","index","indexOf","next","focusPrev","prev","handleKeyDown","event","focusedElement","key","preventDefault","metaKey","typeAheadHandler","typeAhead","updateMenuItems","getFirstMenuItem","handleSizeChange","componentWillLoad","TypeAheadHandler","disconnectedCallback","_a","clearTimeout","render","h","Host","onKeyDown","class","part","role","isHtmlElement","constructor","optionNodes","typeAheadQuery","getElementByQuery","query","toLowerCase","values","_options","option","textContent","trim","findIndex","value","currentIndex","matchingLabel","sort","currentElement","match","isPrintableCharacter","focusableElement","typeAheadTimeout","window","options","isArray"],"sourceRoot":""}